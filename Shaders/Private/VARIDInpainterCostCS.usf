// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#pragma once

#include "/Engine/Private/Common.ush"
#include "VARIDCommon.ush"

uint2 InDispatchThreadIDOffset;
float2 InTexelSize;
SamplerState InBilinearSampler;
SamplerState InPointSampler;
uint2 InTextureSize;
float InFloatMax;
Texture2D<float4> InColourSRV;
Texture2D<float> InMaskSRV;
Texture2D<float2> InPositionSRV;
RWTexture2D<float4> OutPositionCostUAV;

static const uint MaxNumberOfRandomSearchIterations = 10;
static const float Alpha = 1.0;    // 0.0 means no spatial cost considered. 1.0 means no appearance cost considered
static const float SpatialCostAlpha = Alpha;
static const float AppearanceCostAlpha = 1.0 - Alpha;
//static const float DistanceThreshold = 1;// pow(max(InTextureSize.x, InTextureSize.y) * 0.5, 2.0);    // value is SSD for performance
//static const float SpatialCostWeight = 0.25;	// 1/4
//static const float SpatialNormFactor = DistanceThreshold * 2.0;
//static const float AppearanceCostWeight = 0.04;	// 1/25
//static const float AppearanceNormFactor = 255.0 * 255.0 * 3.0;	// =195,075	// dot product of rgb and rgb. 255 per colour channel. 3 channels

// assigns a cost based on the colour difference between target and ref
float ____CalcAppearanceCost(uint2 InTargetID, uint2 InSourceID)
{
	float AppearanceCost = 0.0;
	int lo = -1;
	int hi = 2;

	//[unroll]
	for (int i = lo; i < hi; ++i)
	{
		//[unroll]
		for (int j = lo; j < hi; ++j)
		{
			int2 Offset = uint2(i, j);
			int2 TestSourceID = InSourceID + Offset;

			if (InMaskSRV[TestSourceID].r > MaskThreshold)
			{
				AppearanceCost += 25000000 / 25.0f; // divide by total number of pixels in kernel. e.g. 25 because kernel is 5x5. prevents overflow if all points of the kernel are in the mask
			}
			else
			{
				int2 TestTargetID = InTargetID + Offset;
			////float3 DiffColours = InColourSRV[TestTargetID].rgb * 255.0 - InColourSRV[TestSourceID].rgb * 255.0;
			//float3 DiffColours = InColourSRV[TestTargetID].rgb - InColourSRV[TestSourceID].rgb;
			//AppearanceCost += dot(DiffColours, DiffColours);

				AppearanceCost += distance(InColourSRV[TestSourceID].rgb, InColourSRV[TestTargetID].rgb);
			}
		}
	}

	return AppearanceCostAlpha * AppearanceCost * 0.04 / 1.0;
}

float CalcSpatialCost(uint2 InTargetID, uint2 InSourceID)
{
	float SpatialCost = 0.0;

	SpatialCost += distance((InSourceID + TopOffset).xy, InPositionSRV[InTargetID + TopOffset].xy * InTextureSize.xy);
	SpatialCost += distance((InSourceID + RightOffset).xy, InPositionSRV[InTargetID + RightOffset].xy * InTextureSize.xy);
	SpatialCost += distance((InSourceID + BottomOffset).xy, InPositionSRV[InTargetID + BottomOffset].xy * InTextureSize.xy);
	SpatialCost += distance((InSourceID + LeftOffset).xy, InPositionSRV[InTargetID + LeftOffset].xy * InTextureSize.xy);

	//SpatialCost += distance((InSourceID + TopLeftOffset).xy, InPositionSRV[InTargetID + TopLeftOffset].xy * InTextureSize.xy);
	//SpatialCost += distance((InSourceID + TopRightOffset).xy, InPositionSRV[InTargetID + TopRightOffset].xy * InTextureSize.xy);
	//SpatialCost += distance((InSourceID + BottomLeftOffset).xy, InPositionSRV[InTargetID + BottomLeftOffset].xy * InTextureSize.xy);
	//SpatialCost += distance((InSourceID + BottomRightOffset).xy, InPositionSRV[InTargetID + BottomRightOffset].xy * InTextureSize.xy);

	//return SpatialCostAlpha * SpatialCost * 0.25 / 2.0;
	return SpatialCost / 4.0;
}

float CalcAppearanceCost(uint2 InTargetID, uint2 InSourceID)
{
	float AppearanceCost = 0.0;
	return 0.0;

	AppearanceCost += distance(InColourSRV[InSourceID + TopOffset].rgb, InColourSRV[InPositionSRV[InTargetID + TopOffset].xy * InTextureSize.xy].rgb);
	AppearanceCost += distance(InColourSRV[InSourceID + RightOffset].rgb, InColourSRV[InPositionSRV[InTargetID + RightOffset].xy * InTextureSize.xy].rgb);
	AppearanceCost += distance(InColourSRV[InSourceID + BottomOffset].rgb, InColourSRV[InPositionSRV[InTargetID + BottomOffset].xy * InTextureSize.xy].rgb);
	AppearanceCost += distance(InColourSRV[InSourceID + LeftOffset].rgb, InColourSRV[InPositionSRV[InTargetID + LeftOffset].xy * InTextureSize.xy].rgb);

	//AppearanceCost += distance(InColourSRV[InSourceID + TopLeftOffset].rgb, InColourSRV[InPositionSRV[InTargetID + TopLeftOffset].xy * InTextureSize.xy].rgb);
	//AppearanceCost += distance(InColourSRV[InSourceID + TopRightOffset].rgb, InColourSRV[InPositionSRV[InTargetID + TopRightOffset].xy * InTextureSize.xy].rgb);
	//AppearanceCost += distance(InColourSRV[InSourceID + BottomLeftOffset].rgb, InColourSRV[InPositionSRV[InTargetID + BottomLeftOffset].xy * InTextureSize.xy].rgb);
	//AppearanceCost += distance(InColourSRV[InSourceID + BottomRightOffset].rgb, InColourSRV[InPositionSRV[InTargetID + BottomRightOffset].xy * InTextureSize.xy].rgb);

	//AppearanceCost += distance(InColourSRV[InSourceID + TopOffset].rgb, InColourSRV[InTargetID + TopOffset].rgb);
	//AppearanceCost += distance(InColourSRV[InSourceID + RightOffset].rgb, InColourSRV[InTargetID + RightOffset].rgb);
	//AppearanceCost += distance(InColourSRV[InSourceID + BottomOffset].rgb, InColourSRV[InTargetID + BottomOffset].rgb);
	//AppearanceCost += distance(InColourSRV[InSourceID + LeftOffset].rgb, InColourSRV[InTargetID + LeftOffset].rgb);

	//AppearanceCost += distance(InColourSRV[InSourceID + TopLeftOffset].rgb, InColourSRV[InTargetID + TopLeftOffset].rgb);
	//AppearanceCost += distance(InColourSRV[InSourceID + TopRightOffset].rgb, InColourSRV[InTargetID + TopRightOffset].rgb);
	//AppearanceCost += distance(InColourSRV[InSourceID + BottomLeftOffset].rgb, InColourSRV[InTargetID + BottomLeftOffset].rgb);
	//AppearanceCost += distance(InColourSRV[InSourceID + BottomRightOffset].rgb, InColourSRV[InTargetID + BottomRightOffset].rgb);

	return AppearanceCostAlpha * AppearanceCost * 0.25 / 1.0;
}


[numthreads(8, 8, 1)]
void MainCS
(
	uint3 GroupID : SV_GroupID,
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID,
	uint GroupIndex : SV_GroupIndex
)
{
	uint2 ID = InDispatchThreadIDOffset + DispatchThreadID.xy;
	float2 UV = InTexelSize * (ID + 0.5);
	float SpatialCost = 0.0;
	float AppearanceCost = 0.0;

	if (InMaskSRV[ID].r > MaskThreshold)
	{
		uint2 TargetID = ID;
		UV = InPositionSRV[TargetID].xy;
		uint2 SourceID = UV * InTextureSize.xy;

		// cost of current mapping
		SpatialCost = CalcSpatialCost(TargetID, SourceID);
		AppearanceCost = CalcAppearanceCost(TargetID, SourceID);
		float TotalCost = SpatialCost + AppearanceCost;

		// try random guesses to find a lower cost mapping
		uint RandomSearchIteration = 0;
		float SpatialCostRandom = 0.0;
		float AppearanceCostRandom = 0.0;
		float TotalCostRandom = TotalCost;
		uint2 SourceRandomID = TargetID;
		float2 RandomUV = UV;

		do
		{
			RandomUV = GetRandomUVOutsideMask(InMaskSRV, InBilinearSampler, SourceRandomID, RandomUV);
			SourceRandomID = RandomUV * InTextureSize;
			SpatialCostRandom = CalcSpatialCost(TargetID, SourceRandomID);
			AppearanceCostRandom = CalcAppearanceCost(TargetID, SourceRandomID);
			TotalCostRandom = SpatialCost + AppearanceCost;
			++RandomSearchIteration;
		} while (TotalCostRandom >= TotalCost && RandomSearchIteration < MaxNumberOfRandomSearchIterations);

		if (TotalCostRandom < TotalCost)
		{
			SpatialCost = SpatialCostRandom;
			AppearanceCost = AppearanceCostRandom;
			UV = RandomUV;
		}
	}

	OutPositionCostUAV[ID].rgba = float4(UV.x, UV.y, SpatialCost, AppearanceCost);
}