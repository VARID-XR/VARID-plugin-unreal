// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#pragma once

#include "/Engine/Private/Common.ush"
#include "VARIDCommon.ush"

uint2 InDispatchThreadIDOffset;
float2 InTexelSize;
int PassCounter;
Texture2D InColourSRV;
Texture2D InMaskSRV;
Texture2D InMetaDataSRV; 
RWTexture2D<float4> OutMetaDataUAV;	//UV.x, UV.y, PassCounter, Fill(0 or 1)
RWTexture2D<float4> OutColourUAV;

[numthreads(8, 8, 1)]
void MainCS
(
	uint3 DispatchThreadID : SV_DispatchThreadID
)
{
	uint2 ID = InDispatchThreadIDOffset + DispatchThreadID.xy;
	PassCounter++;

	float4 BestValue = InMetaDataSRV[ID];	//default is passthrough whether it be mask, edge or not

	 // TODO try intensity diff intead of colour
	// LAB colour doesnt seem to improve things
	// TODO add weightings - to control how data is propagated

	if (InMaskSRV[ID].r > MaskThreshold)
	{
		if (InMetaDataSRV[ID].a == 1.0)
		{
			float LowestDiff = 0.1;

			float3 AccumulatedColour = float3(0, 0, 0);
			int NumColours = 0;

			// in a clockwise order around the compass

			if (InMetaDataSRV[ID + TopOffset].a == 0.0)
			{
				AccumulatedColour += InColourSRV[ID + TopOffset].rgb;
				NumColours++;
			}

			if (InMetaDataSRV[ID + TopRightOffset].a == 0.0)
			{
				AccumulatedColour += InColourSRV[ID + TopRightOffset].rgb;
				NumColours++;
			}

			if (InMetaDataSRV[ID + RightOffset].a == 0.0)
			{
				AccumulatedColour += InColourSRV[ID + RightOffset].rgb;
				NumColours++;
			}

			if (InMetaDataSRV[ID + BottomRightOffset].a == 0.0)
			{
				AccumulatedColour += InColourSRV[ID + BottomRightOffset].rgb;
				NumColours++;
			}

			if (InMetaDataSRV[ID + BottomOffset].a == 0.0)
			{
				AccumulatedColour += InColourSRV[ID + BottomOffset].rgb;
				NumColours++;
			}

			//if (InMetaDataSRV[ID + BottomLeftOffset].a == 0.0)
			{
				AccumulatedColour += InColourSRV[ID + BottomLeftOffset].rgb;
				NumColours++;
			}

			//if (InMetaDataSRV[ID + LeftOffset].a == 0.0)
			{
				AccumulatedColour += InColourSRV[ID + LeftOffset].rgb;
				NumColours++;
			}

			//if (InMetaDataSRV[ID + TopLeftOffset].a == 0.0)
			{
				AccumulatedColour += InColourSRV[ID + TopLeftOffset].rgb;
				NumColours++;
			}

			float Colour = AccumulatedColour / NumColours;

			if (InMetaDataSRV[ID + TopOffset].a == 0.0)
			{
				float3 TopColour = InColourSRV[InMetaDataSRV[ID + TopOffset].xy].rgb;			

				if (InMetaDataSRV[ID + TopLeftOffset].a == 0.0 && InMetaDataSRV[ID + TopRightOffset].a == 0.0)
				{
					float3 TopLeftColour = InColourSRV[InMetaDataSRV[ID + TopLeftOffset].xy].rgb;
					float3 TopRightColour = InColourSRV[InMetaDataSRV[ID + TopRightOffset].xy].rgb;

					float DiffColour = length(TopLeftColour - TopRightColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + TopOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}

				if (InMetaDataSRV[ID + LeftOffset].a == 0.0)
				{
					float3 LeftColour = InColourSRV[InMetaDataSRV[ID + LeftOffset].xy].rgb;

					float DiffColour = length(TopColour - LeftColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + TopLeftOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}
				
				if (InMetaDataSRV[ID + RightOffset].a == 0.0)
				{
					float3 RightColour = InColourSRV[InMetaDataSRV[ID + RightOffset].xy].rgb;

					float DiffColour = length(TopColour - RightColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + TopRightOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}
			}

			if (InMetaDataSRV[ID + BottomOffset].a == 0.0)
			{
				float3 BottomColour = InColourSRV[InMetaDataSRV[ID + BottomOffset].xy].rgb;

				if(InMetaDataSRV[ID + BottomLeftOffset].a == 0.0 && InMetaDataSRV[ID + BottomRightOffset].a == 0.0)
				{
					float3 BottomLeftColour = InColourSRV[InMetaDataSRV[ID + BottomLeftOffset].xy].rgb;
					float3 BottomRightColour = InColourSRV[InMetaDataSRV[ID + BottomRightOffset].xy].rgb;

					float DiffColour = length(BottomLeftColour - BottomRightColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + TopOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}

				if (InMetaDataSRV[ID + LeftOffset].a == 0.0)
				{
					float3 LeftColour = InColourSRV[InMetaDataSRV[ID + LeftOffset].xy].rgb;

					float DiffColour = length(BottomColour - LeftColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + BottomLeftOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}
				
				if (InMetaDataSRV[ID + RightOffset].a == 0.0)
				{
					float3 RightColour = InColourSRV[InMetaDataSRV[ID + RightOffset].xy].rgb;

					float DiffColour = length(BottomColour - RightColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + BottomRightOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}						
			}
		}
	}

	OutMetaDataUAV[ID] = BestValue;
}