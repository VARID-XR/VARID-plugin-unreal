// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#pragma once

#include "/Engine/Private/Common.ush"
#include "VARIDCommon.ush"

uint2 InDispatchThreadIDOffset;
float2 InTexelSize;
int PassCounter;
Texture2D InColourSRV;
Texture2D InMaskSRV;
Texture2D InMetaDataSRV;
RWTexture2D<float4> OutMetaDataUAV;

float3 rgb2xyz(float3 c) {
	float3 tmp;
	tmp.x = (c.r > 0.04045) ? pow((c.r + 0.055) / 1.055, 2.4) : c.r / 12.92;
	tmp.y = (c.g > 0.04045) ? pow((c.g + 0.055) / 1.055, 2.4) : c.g / 12.92,
		tmp.z = (c.b > 0.04045) ? pow((c.b + 0.055) / 1.055, 2.4) : c.b / 12.92;

	const float3x3 mat = float3x3(
		0.4124, 0.3576, 0.1805,
		0.2126, 0.7152, 0.0722,
		0.0193, 0.1192, 0.9505
	);

	return 100.0 * mul(tmp, mat);
}

float3 xyz2lab(float3 c) {
	float3 n = c / float3(95.047, 100, 108.883);
	float3 v;
	v.x = (n.x > 0.008856) ? pow(n.x, 1.0 / 3.0) : (7.787 * n.x) + (16.0 / 116.0);
	v.y = (n.y > 0.008856) ? pow(n.y, 1.0 / 3.0) : (7.787 * n.y) + (16.0 / 116.0);
	v.z = (n.z > 0.008856) ? pow(n.z, 1.0 / 3.0) : (7.787 * n.z) + (16.0 / 116.0);
	return float3((116.0 * v.y) - 16.0, 500.0 * (v.x - v.y), 200.0 * (v.y - v.z));
}

float3 rgb2lab(float3 c) {
	return c;

	float3 lab = xyz2lab(rgb2xyz(c));
	return float3(lab.x / 100.0, 0.5 + 0.5 * (lab.y / 127.0), 0.5 + 0.5 * (lab.z / 127.0));
}

[numthreads(8, 8, 1)]
void MainCS
(
	uint3 DispatchThreadID : SV_DispatchThreadID
)
{
	uint2 ID = InDispatchThreadIDOffset + DispatchThreadID.xy;
	PassCounter++;

	float4 BestValue = InMetaDataSRV[ID];	//default is passthrough

	 // TODO try intensity diff intead of colour
	// LAB colour doesnt seem to improve things
	// TODO add weightings - to control how data is propagated

	if (InMaskSRV[ID].r > MaskThreshold)
	{
		if (InMetaDataSRV[ID].a == 1.0)
		{
			float LowestDiff = 0.1;

			if (InMetaDataSRV[ID + TopOffset].a == 0.0)
			{
				float3 TopColour = rgb2lab(InColourSRV[InMetaDataSRV[ID + TopOffset].xy].rgb);

				if (InMetaDataSRV[ID + LeftOffset].a == 0.0)
				{
					float3 LeftColour = rgb2lab(InColourSRV[InMetaDataSRV[ID + LeftOffset].xy].rgb);

					float DiffColour = length(TopColour - LeftColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + TopLeftOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}
				
				if (InMetaDataSRV[ID + RightOffset].a == 0.0)
				{
					float3 RightColour = rgb2lab(InColourSRV[InMetaDataSRV[ID + RightOffset].xy].rgb);

					float DiffColour = length(TopColour - RightColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + TopRightOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}
				
				//if (InMetaDataSRV[ID + TopLeftOffset].a == 0.0 && InMetaDataSRV[ID + TopRightOffset].a == 0.0)
				//{
				//	float3 TopLeftColour = InColourSRV[InMetaDataSRV[ID + TopLeftOffset].xy].rgb;
				//	float3 TopRightColour = InColourSRV[InMetaDataSRV[ID + TopRightOffset].xy].rgb;

				//	float DiffColour = length(TopLeftColour - TopRightColour);

				//	if (DiffColour < LowestDiff)
				//	{
				//		LowestDiff = DiffColour;
				//		float2 UV = InMetaDataSRV[ID + TopOffset].xy;
				//		BestValue = float4(UV.x, UV.y, PassCounter, 0);
				//	}
				//}
			}

			if (InMetaDataSRV[ID + BottomOffset].a == 0.0)
			{
				float3 BottomColour = rgb2lab(InColourSRV[InMetaDataSRV[ID + BottomOffset].xy].rgb);

				if (InMetaDataSRV[ID + LeftOffset].a == 0.0)
				{
					float3 LeftColour = rgb2lab(InColourSRV[InMetaDataSRV[ID + LeftOffset].xy].rgb);

					float DiffColour = length(BottomColour - LeftColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + BottomLeftOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}
				
				if (InMetaDataSRV[ID + RightOffset].a == 0.0)
				{
					float3 RightColour = rgb2lab(InColourSRV[InMetaDataSRV[ID + RightOffset].xy].rgb);

					float DiffColour = length(BottomColour - RightColour);

					if (DiffColour < LowestDiff)
					{
						LowestDiff = DiffColour;
						float2 UV = InMetaDataSRV[ID + BottomRightOffset].xy;
						BestValue = float4(UV.x, UV.y, PassCounter, 0);
					}
				}
								
				//if(InMetaDataSRV[ID + BottomLeftOffset].a == 0.0 && InMetaDataSRV[ID + BottomRightOffset].a == 0.0)
				//{
				//	float3 BottomLeftColour = InColourSRV[InMetaDataSRV[ID + BottomLeftOffset].xy].rgb;
				//	float3 BottomRightColour = InColourSRV[InMetaDataSRV[ID + BottomRightOffset].xy].rgb;

				//	float DiffColour = length(BottomLeftColour - BottomRightColour);

				//	if (DiffColour < LowestDiff)
				//	{
				//		LowestDiff = DiffColour;
				//		float2 UV = InMetaDataSRV[ID + TopOffset].xy;
				//		BestValue = float4(UV.x, UV.y, PassCounter, 0);
				//	}
				//}
			}
		}
	}

	OutMetaDataUAV[ID] = BestValue;
}